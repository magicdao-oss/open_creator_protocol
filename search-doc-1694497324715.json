[{"title":"CLI Usage","type":0,"sectionRef":"#","url":"/open_creator_protocol/open-creator-protocol/cli","content":"CLI Usage The CLI can be executed by running the following from the project directory: git clone https://github.com/magiceden-oss/open_creator_protocol.git cd open_creator_protocol ts-node sdk/src/cli.ts Create a policy without a dynamic royalty setting: CLI_COMMAND=create_policy \\ CLI_AUTHORITY=./keypair.json \\ CLI_RPC=https://api.devnet.solana.com \\ CLI_JSON_RULE='{&quot;conditions&quot;:{&quot;field&quot;:&quot;action&quot;,&quot;operator&quot;:&quot;string_not_equals&quot;,&quot;value&quot;:&quot;&quot;},&quot;events&quot;:[]}' \\ ts-node sdk/src/cli.ts Create a policy with a dynamic royalty setting: CLI_COMMAND=create_policy \\ CLI_AUTHORITY=./keypair.json \\ CLI_RPC=https://api.devnet.solana.com \\ CLI_JSON_RULE='{&quot;conditions&quot;:{&quot;field&quot;:&quot;action&quot;,&quot;operator&quot;:&quot;string_not_equals&quot;,&quot;value&quot;:&quot;&quot;},&quot;events&quot;:[]}' \\ CLI_DYNAMIC_ROYALTY_PRICE_LINEAR='{&quot;startPrice&quot;:0,&quot;endPrice&quot;:5000000000,&quot;startMultiplierBp&quot;:10000,&quot;endMultiplierBp&quot;:0}' \\ ts-node sdk/src/cli.ts Update a policy CLI_POLICY_PUBKEY=TODO \\ CLI_COMMAND=update_policy \\ CLI_AUTHORITY=./keypair.json \\ CLI_RPC=https://api.devnet.solana.com \\ CLI_JSON_RULE='{&quot;conditions&quot;:{&quot;field&quot;:&quot;action&quot;,&quot;operator&quot;:&quot;string_not_equals&quot;,&quot;value&quot;:&quot;&quot;},&quot;events&quot;:[]}' \\ CLI_DYNAMIC_ROYALTY_PRICE_LINEAR='{&quot;startPrice&quot;:0,&quot;endPrice&quot;:5000000000,&quot;startMultiplierBp&quot;:10000,&quot;endMultiplierBp&quot;:0}' \\ ts-node sdk/src/cli.ts Migrate OCP to MPL CLI_COMMAND=migrate_to_mpl \\ CLI_POLICY_PUBKEY=TODO \\ CLI_MINT=TODO \\ CLI_UPDATE_AUTHORITY=./metadata_update_authority_keypair.json \\ CLI_RPC=https://api.devnet.solana.com \\ ts-node sdk/src/cli.ts ","keywords":"solana  magic eden  ocp  open creator protocol"},{"title":"On-chain Accounts","type":0,"sectionRef":"#","url":"/open_creator_protocol/open-creator-protocol/on-chain-accounts","content":"On-chain Accounts There are some useful default onchain accounts that people can use or test for OCP tokens. Creating policies is completely permissionless, and it's up to the creators to decide their own policies for their collections. Network\tType\tAddressDevnet\tProgram\tocp4vWUzA2z2XMYJ3QhM9vWdyoyoQwAFJhRdVTbvo9E Devnet\tPolicy (default denylist: [])\t6Sp2zwcFM7TkGHFUJjWVVpPPeioyqbQHmCocczcw2F1Y Devnet\tPolicy (allow all)\t6Huqrb4xxmmNA4NufYdgpmspoLmjXFd3qEfteCddLgSzNetwork\tType\tAddressMainnet\tProgram\tocp4vWUzA2z2XMYJ3QhM9vWdyoyoQwAFJhRdVTbvo9E Mainnet\tPolicy (default denylist: [])\t2jfkE654yAZDP3FfowFZ2bwA5MbQKnAWZaEQv44L1BB4 Mainnet\tPolicy (allow all)\t7evQhBswiztNd6HLvNWsh1Ekc3fmyvQGnL82uDepSMbw","keywords":"solana  magic eden  ocp  open creator protocol"},{"title":"Concepts","type":0,"sectionRef":"#","url":"/open_creator_protocol/open-creator-protocol/concepts","content":"","keywords":"solana  magic eden  ocp  open creator protocol"},{"title":"Action Context​","type":1,"pageTitle":"Concepts","url":"/open_creator_protocol/open-creator-protocol/concepts#action-context","content":"Action context is the context used to build the json rules engine. OCP's solution is a JSON rules engine DSL to define what can be applied to the context. pub struct ActionCtx { pub action: String, pub program_ids: Vec&lt;String&gt;, pub mint: String, pub mint_state: MintStateCtx, pub mint_account: Option&lt;MintAccountCtx&gt;, pub metadata: Option&lt;MetadataCtx&gt;, pub payer: Option&lt;String&gt;, pub from: Option&lt;String&gt;, // owner of the from_account, and many action's initiator pub to: Option&lt;String&gt;, // owner of the to_account pub last_memo_signer: Option&lt;String&gt;, pub last_memo_data: Option&lt;String&gt;, }   "},{"title":"Onchain Policy Engine​","type":1,"pageTitle":"Concepts","url":"/open_creator_protocol/open-creator-protocol/concepts#onchain-policy-engine","content":"OCP utilises the JSON Rules Engine package, for more information please see the repository. Sample Use Cases\tPolicy (json_rule)Allow For All\tnull Program IDs Allowlist\t{ &quot;field&quot;: &quot;program_ids&quot;, &quot;operator&quot;: &quot;string_is_subset&quot;, &quot;value&quot;: [&quot;1111111111111111111111111111111&quot;]} Program IDs Denylist\t{ &quot;field&quot;: &quot;program_ids&quot;, &quot;operator&quot;: &quot;string_does_not_contain_any&quot;, &quot;value&quot;: [&quot;1111111111111111111111111111111&quot;]} Soulbound Token\t{ &quot;field&quot;: &quot;mint_state/transferred_count&quot;, &quot;operator&quot;: &quot;int_less_than&quot;, &quot;value&quot;: 1 } Semi Soulbound Token\t{ &quot;field&quot;: &quot;mint_state/transferred_count&quot;, &quot;operator&quot;: &quot;int_less_than&quot;, &quot;value&quot;: n } Transfer Timestamp Constraint\t{ &quot;field&quot;: &quot;mint_state/derived_datetime/utc_timestamp&quot;, &quot;operator&quot;: &quot;int_greater_than&quot;, &quot;value&quot;: 1669881409} Transfer Cooldown Token\t{ &quot;field&quot;: &quot;mint_state/derived_cooldown&quot;, &quot;operator&quot;: &quot;int_greater_than&quot;, &quot;value&quot;: 3600 } Metadata Name Filter\t{ &quot;field&quot;: &quot;metadata/name&quot;, &quot;operator&quot;: &quot;string_has_substring&quot;, &quot;value&quot;: &quot;FROZEN&quot;} Metadata URI Filter\t{ &quot;field&quot;: &quot;metadata/uri&quot;, &quot;operator&quot;: &quot;string_has_substring&quot;, &quot;value&quot;: &quot;IPFS&quot;} Single Transfer Destination\t{ &quot;field&quot;: &quot;to&quot;, &quot;operator&quot;: &quot;string_equals&quot;, &quot;value&quot;: [&quot;1111111111111111111111111111111&quot;]} A Complex Transfer Logic Example Here's a full example of how a creator can leverage OCP to personalize the transferability. The logic works like this: When the action is not transfer, passWhen the action is transfer, then one cannot transfer if the metadata/name contains a keyword FROZENWhen the action is transfer, then one cannot transfer to a specific address if the metadata/name doesn't contain WINNER. Example of the &quot;Magic Mint&quot;'s complex policy can be found on the solana explorer link. { &quot;events&quot;: [], &quot;conditions&quot;: { &quot;or&quot;: [ { &quot;field&quot;: &quot;action&quot;, &quot;operator&quot;: &quot;string_not_equals&quot;, &quot;value&quot;: &quot;transfer&quot; }, { &quot;and&quot;: [ { &quot;not&quot;: { &quot;field&quot;: &quot;metadata/name&quot;, &quot;operator&quot;: &quot;string_has_substring&quot;, &quot;value&quot;: &quot;FROZEN&quot; } }, { &quot;or&quot;: [ { &quot;field&quot;: &quot;to&quot;, &quot;operator&quot;: &quot;string_not_equals&quot;, &quot;value&quot;: &quot;DWuopEsTrg5qWMSMVT1hoiVTRQG9PkGJZSbXiKAxHYbn&quot; }, { &quot;field&quot;: &quot;metadata/name&quot;, &quot;operator&quot;: &quot;string_has_substring&quot;, &quot;value&quot;: &quot;WINNER&quot; } ] } ] } ] } }  "},{"title":"Mint State​","type":1,"pageTitle":"Concepts","url":"/open_creator_protocol/open-creator-protocol/concepts#mint-state","content":"MintState determines if a mint (token) is with OCP or not. Mint state is a key PDA that OCP uses to associate a mint account with a policy and some state information related to the mint account. pub struct MintState { pub version: u8, pub bump: [u8; 1], pub mint: Pubkey, pub policy: Pubkey, pub locked_by: Option&lt;Pubkey&gt;, pub last_approved_at: i64, pub last_transferred_at: i64, pub transferred_count: u32, }  One can use the findMintStatePk to test if a mint account has a MintState account, and then leverage what OCP program provides. export const findMintStatePk = (mint: PublicKey) =&gt; { return PublicKey.findProgramAddressSync( [utils.bytes.utf8.encode(&quot;mint_state&quot;), mint.toBuffer()], PROGRAM_ID )[0]; }; const mintStatePk = findMintStatePk(mint); const mintStateAcc = await conn.getAccountInfo(mintStatePk): // returns null | AccountInfo&lt;Buffer&gt;, and then you can decide if it's OCP going forward.  "},{"title":"Dynamic Royalties​","type":1,"pageTitle":"Concepts","url":"/open_creator_protocol/open-creator-protocol/concepts#dynamic-royalties","content":"Creators can specify a relationship between an NFT’s sale price and royalty amount via a linear price curve. And more curve types to be supported in the future. The first dynamic royalty curve OCP supports is DynamicRoyaltyPriceLinear. Both start_multiplier_bp and end_multiplier_bp are relative multipliers based on the Metaplex's metadata.seller_fee_basis_points. pub struct DynamicRoyaltyPriceLinear { pub price_mint: Option&lt;Pubkey&gt;, pub start_price: u64, pub end_price: u64, pub start_multiplier_bp: u16, pub end_multiplier_bp: u16, }  Specifically, if we note that r is the final multiplier_bp, then: r=y1+(y2−y1)∗(price−x1)/(x2−x1)r = y1 + (y2 - y1) * (price - x1) / (x2 - x1)r=y1+(y2−y1)∗(price−x1)/(x2−x1) For example, given the following dynamic royalty setting: DynamicRoyaltyPriceLinear: { start_price: 0 SOL end_price: 5 SOL start_multiplier_bp: 100% (10000 bp) end_multiplier_bp: 50% (5000 bp) } Metadata: seller_fee_basis_points: 5% (500 bp) price: 0 SOL ===&gt; royalty_bp: 500 (5%) price: 2.5 SOL ===&gt; royalty_bp: 375 (3.75%) price: 5 SOL ===&gt; royalty_bp: 250 (2.5%)  "},{"title":"Overview","type":0,"sectionRef":"#","url":"/open_creator_protocol/open-creator-protocol/overview","content":"","keywords":"solana  magic eden  ocp  open creator protocol"},{"title":"How to get started with Open Creator Protocol​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#how-to-get-started-with-open-creator-protocol","content":"Get familiar with deploying the Open Creator Protocol by reading the Tutorials.New creators can mint their collection with the Open Creator Protocol CLI tool.If you are interested in applying to Launchpad and using Open Creator Protocol, please fill out an inquiry form. Of course, collections do not need to launch on Launchpad in order to use Open Creator Protocol. "},{"title":"Features​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#features","content":"We created this Open Creator Protocol because we wanted to provide tools to creators as soon as possible. We look forward to a world where there are different standards and creators can choose what works best for them. See below for the full feature list. "},{"title":"Protected royalties​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#protected-royalties","content":"We will protect royalties on all collections who adopt the standard. The protocol allows creators to ban marketplaces that have not protected royalties on their collection. For new collections that do not adopt the standard, royalties will remain optional on Magic Eden. We will also welcome the inclusion of other future royalty protection protocols that emerge and gain market adoption. "},{"title":"Open source​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#open-source","content":"This is a tool built on top of Solana’s SPL managed-token standard. Creators will be in control of creating and managing the rules of their collection. "},{"title":"Dynamic royalties​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#dynamic-royalties","content":"Creators can specify a relationship between an NFT’s sale price and royalty amount via a linear price curve. For example, creators can reduce the nominal value of royalties for buyers who pay a higher price for the NFT. "},{"title":"Freeze trading until mint is done​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#freeze-trading-until-mint-is-done","content":"Creators can use Open Creator Protocol to limit trading until after mint is complete (only time based) "},{"title":"Create rules for NFT transfers​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#create-rules-for-nft-transfers","content":"Creators can game-ify transferability for collections, including completely non-transferable tokens (or restrictions based on time, # of transfers, or metadata name) "},{"title":"Bulk transfers directly on Magic Eden​","type":1,"pageTitle":"Overview","url":"/open_creator_protocol/open-creator-protocol/overview#bulk-transfers-directly-on-magic-eden","content":"Magic Eden is also unveiling bulk transfers on the platform so collectors can move their NFTs freely for collections using the Open Creator Protocol. These bulk transfers will be subject to the token transferability rules the creator sets. "},{"title":"Tutorials","type":0,"sectionRef":"#","url":"/open_creator_protocol/open-creator-protocol/tutorials","content":"","keywords":"solana  magic eden  ocp  open creator protocol"},{"title":"How to interact with OCP NFT​","type":1,"pageTitle":"Tutorials","url":"/open_creator_protocol/open-creator-protocol/tutorials#how-to-interact-with-ocp-nft","content":"For javascript sdk examples, please take a look at thetests/token.spec.ts. import { createTransferInstruction, process_tx } from &quot;@magiceden-oss/open_creator_protocol&quot;; const transferIx = createTransferInstruction({ policy: DEVNET_POLICY_ALL, freezeAuthority: findFreezeAuthorityPk(DEVNET_POLICY_ALL), mint: tokenMint, metadata: findMetadataPda(tokenMint), mintState: findMintStatePk(tokenMint), from: alice.publicKey, fromAccount: aliceAta, cmtProgram: CMT_PROGRAM, instructions: SYSVAR_INSTRUCTIONS_PUBKEY, to: bob.publicKey, toAccount: bobAta, }); await process_tx(conn, [computeBudgetIx, initAccIx, transferIx], [alice]);  For solana programs using cpi, here's an example of doing the transfer. [dependencies] open_creator_protocol = { version = &quot;0.3.0&quot;, features = [&quot;cpi&quot;] }  open_creator_protocol::cpi::transfer(CpiContext::new( ctx.accounts.ocp_program.to_account_info(), open_creator_protocol::cpi::accounts::TransferCtx { policy: ctx.accounts.ocp_policy.to_account_info(), mint: ctx.accounts.token_mint.to_account_info(), metadata: ctx.accounts.metadata.to_account_info(), mint_state: ctx.accounts.ocp_mint_state.to_account_info(), from: ctx.accounts.program_as_signer.to_account_info(), from_account: ctx.accounts.seller_token_ata.to_account_info(), cmt_program: ctx.accounts.cmt_program.to_account_info(), instructions: ctx.accounts.instructions.to_account_info(), freeze_authority: ctx.accounts.ocp_freeze_authority.to_account_info(), token_program: ctx.accounts.token_program.to_account_info(), to: ctx.accounts.buyer.to_account_info(), to_account: ctx.accounts.buyer_token_ata.to_account_info(), }, ))?;  "},{"title":"How to mint OCP NFT​","type":1,"pageTitle":"Tutorials","url":"/open_creator_protocol/open-creator-protocol/tutorials#how-to-mint-ocp-nft","content":"To mint an OCP NFT please follow these instructions. Create or use an existing policy accountCreate mint accountCreate metadata accountCall wrap in OCP to wrap the mint account with the policyCall init_account in OCP to create the token account ataCall mint_to in OCP to actually mint into the token account using the mint account. For more details, please take a look at the util.ts example. "},{"title":"How to lock/unlock OCP NFT for trading/staking/loan​","type":1,"pageTitle":"Tutorials","url":"/open_creator_protocol/open-creator-protocol/tutorials#how-to-lockunlock-ocp-nft-for-tradingstakingloan","content":"OCP NFT provides a convinent way of &quot;lock/unlock&quot; as a higher order of freezing. For example, if we want to implement escrowless listing in a marketplace. This is also true for any staking or loan platform wants to have escrowless lock-in of user tokens. // List 1. Call `approve` in OCP to setup the delegate just like normal tokens 2. Call `lock` in OCP to lock the token. It prevents the OCP token from accepting any other actions // Delist 1. Call `unlock` in OCP to unlock the token 2. Call `revoke` in OCP to revoke the previously approved delegate  "},{"title":"How to create a policy​","type":1,"pageTitle":"Tutorials","url":"/open_creator_protocol/open-creator-protocol/tutorials#how-to-create-a-policy","content":"const jsonRule = JSON.stringify({ events: [], conditions: { and: [{ field: &quot;action&quot;, operator: &quot;string_not_equals&quot;, value: &quot;&quot; }], }, }); const ix = createInitPolicyInstruction( { policy: findPolicyPk(uuid), authority: alice.publicKey, uuid, }, { arg: { jsonRule, dynamicRoyalty: null } } ); await process_tx(conn, [ix], [alice]);  "},{"title":"How to update a policy​","type":1,"pageTitle":"Tutorials","url":"/open_creator_protocol/open-creator-protocol/tutorials#how-to-update-a-policy","content":"const jsonRule = JSON.stringify({ events: [], conditions: { and: [{ field: &quot;action&quot;, operator: &quot;string_not_equals&quot;, value: &quot;&quot; }], }, }); ix = createUpdatePolicyInstruction( { policy: findPolicyPk(uuid), authority: alice.publicKey }, { arg: { authority: bob.publicKey, jsonRule, dynamicRoyalty: null } } ); await process_tx(conn, [ix], [alice]);  "},{"title":"How to migrate OCP token back to other standards (e.g. Metaplex Master Edition)​","type":1,"pageTitle":"Tutorials","url":"/open_creator_protocol/open-creator-protocol/tutorials#how-to-migrate-ocp-token-back-to-other-standards-eg-metaplex-master-edition","content":"Notice that OCP NFTs are based on spl-managed-token, spl-token, and token metadata programs. Token Mint (supply = 1, decimals = 0)Token AccountToken Metadata By definition, it's the same implementation of all the NFTs on solana. Everything is the same including interacting with wallets (except &quot;transfer&quot;, that users can use ME profile page to send tokens including OCP NFTs), run token gated content, and prove token ownerships exactly like the normal Normal NFTs. OCP provides an upstream authority to interact with spl-managed-token that wraps the token interfaces. And if creators want to migrate from OCP to other standards, the seamless way of doing that is to call one of the migration entrypoints in OCP. const ix = createMigrateToMplInstruction({ policy: CLI_POLICY_PUBKEY, freezeAuthority: findFreezeAuthorityPk(CLI_POLICY_PUBKEY), mint: CLI_MINT, metadata: findMetadataPda(CLI_MINT), mintState: findMintStatePk(CLI_MINT), from: CLI_UPDATE_AUTHORITY, fromAccount: tokenAccount, cmtProgram: CMT_PROGRAM, instructions: SYSVAR_INSTRUCTIONS_PUBKEY, edition: findMasterEditionV2Pda(CLI_MINT), metadataProgram: TokenMetadataProgram.publicKey, }); await process_tx(conn, [ix], [CLI_UPDATE_AUTHORITY]);  CLI_COMMAND=migrate_to_mpl \\ CLI_POLICY_PUBKEY=TODO \\ CLI_MINT=TODO \\ CLI_UPDATE_AUTHORITY=./metadata_update_authority_keypair.json \\ CLI_RPC=https://api.devnet.solana.com \\ ts-node sdk/src/cli.ts  "},{"title":"How to run OCP locally (for development)​","type":1,"pageTitle":"Tutorials","url":"/open_creator_protocol/open-creator-protocol/tutorials#how-to-run-ocp-locally-for-development","content":"Clone the repository to your local machine: git clone git@github.com:magiceden-oss/open_creator_protocol.git  Setup, build, and test the codebase: # Install deps npm i # To build and generate the solitarc ./build.sh # To test anchor test  "}]